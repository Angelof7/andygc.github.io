<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>AndyStack</title>
    <link href="http://angelof7.github.io/feed/" rel="self" />
    <link href="http://angelof7.github.io" />
    <lastBuildDate>2016-04-25T19:16:26+08:00</lastBuildDate>
    <webMaster>cgao886@163.com</webMaster>
    
    <item>
      <title>Apache ZooKeeper Java Client API 简介</title>
      <link href="http://angelof7.github.io/zookeeper-java-client-api/"/>
      <pubDate>2015-08-03T00:00:00+08:00</pubDate>
      <author>andygc</author>
      <guid>http://angelof7.github.io/zookeeper-java-client-api</guid>
      <content:encoded><![CDATA[<h3 id="apache-zookeeper">Apache ZooKeeper:</h3>
<hr />
<p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、名字服务、分布式同步、组服务等。
ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。
ZooKeeper包含一个简单的原语集, 提供Java和C的接口。</p>

<h3 id="zookeeper-">ZooKeeper 的安装:</h3>
<hr />
<p><a href="http://zookeeper.apache.org">ZooKeeper下载安装</a></p>

<h3 id="java-client-">Java Client 的使用:</h3>
<hr />
<p>Watcher 在 ZooKeeper 是一个核心功能,Watcher 可以监控目录节点的数据变化以及子目录的变化,一旦这些状态发生变化,服务器就会通知所有设置在这个目录节点上的 Watcher,从而每个客户端都很快知道它所关注的目录节点的状态发生变化,而做出相应的反应.
可以设置观察的操作：exists,getChildren,getData</p>

<p>可以触发观察的操作：create,delete,setData</p>

<p>znode以某种方式发生变化时,“观察”(watch)机制可以让客户端得到通知.可以针对ZooKeeper服务的“操作”来设置观察,该服务的其他 操作可以触发观察.</p>

<p>比如,客户端可以对某个客户端调用exists操作,同时在它上面设置一个观察,如果此时这个znode不存在,则exists返回 false,如果一段时间之后,这个znode被其他客户端创建,则这个观察会被触发,之前的那个客户端就会得到通知.</p>

<p>说明: zookeeper客户端对server的操作都是不可回退的。
意 思是说，zk的客户端每次和server进行通信的时候，会记住server上最新的zxid。如果某个时刻，客户端和server断开了连接，那么等到 下次重新连接到集群中的机器上时，会检查当前连接上的那个server是否和client有相同的zxid，或者已经是更新的zxid了。一旦客户端发现 server的zxid比自己小，那么客户端会断开和这个server的连接，并且重新连接集群中的其它server.</p>

<ol>
  <li>连接ZooKeeper服务器</li>
</ol>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/***
*** [关于connectString服务器地址配置]
*** 格式: 192.168.1.1:2181,192.168.1.2:2181,192.168.1.3:2181
*** 这个地址配置有多个ip:port之间逗号分隔,底层操作:
*** ConnectStringParser connectStringParser =  new ConnectStringParser(“192.168.1.1:2181,192.168.1.2:2181,192.168.1.3:2181”);
*** 这个类主要就是解析传入地址列表字符串，将其它保存在一个ArrayList中
*** ArrayList&lt;InetSocketAddress&gt; serverAddresses = new ArrayList&lt;InetSocketAddress&gt;();
*** 接下去，这个地址列表会被进一步封装成StaticHostProvider对象，并且在运行过程中，一直是这个对象来维护整个地址列表。
*** ZK客户端将所有Server保存在一个List中，然后随机打乱(这个随机过程是一次性的)，并且形成一个环，具体使用的时候，从0号位开始一个一个使用。
*** 因此，Server地址能够重复配置，这样能够弥补客户端无法设置Server权重的缺陷，但是也会加大风险。
*** 
*** [客户端和服务端会话说明]
*** ZooKeeper中，客户端和服务端建立连接后，会话随之建立，生成一个全局唯一的会话ID(Session ID)。
*** 服务器和客户端之间维持的是一个长连接，在SESSION_TIMEOUT时间内，服务器会确定客户端是否正常连接(客户端会定时向服务器发送heart_beat，服务器重置下次SESSION_TIMEOUT时间)。
*** 因此，在正常情况下，Session一直有效，并且ZK集群所有机器上都保存这个Session信息。
*** 在出现网络或其它问题情况下（例如客户端所连接的那台ZK机器挂了，或是其它原因的网络闪断）,客户端与当前连接的那台服务器之间连接断了,这个时候客户端会主动在地址列表（实例化ZK对象的时候传入构造方法的那个参数connectString）中选择新的地址进行连接。
***
*** [会话时间]
*** 客户端并不是可以随意设置这个会话超时时间，在ZK服务器端对会话超时时间是有限制的，主要是minSessionTimeout和maxSessionTimeout这两个参数设置的。
*** 如果客户端设置的超时时间不在这个范围，那么会被强制设置为最大或最小时间。 默认的Session超时时间是在2 * tickTime ~ 20 * tickTime
*** @param connectString  Zookeeper服务地址
*** @param sessionTimeout Zookeeper连接超时时间
***/</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">connectionZookeeper</span><span class="p">(</span><span class="n">String</span> <span class="n">connectString</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sessionTimeout</span><span class="o">){</span>
    <span class="k">this</span><span class="o">.</span><span class="na">releaseConnection</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
       <span class="c1">// ZK客户端允许我们将ZK服务器的所有地址都配置在这里</span>
       <span class="n">zk</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ZooKeeper</span><span class="o">(</span><span class="n">connectString</span><span class="o">,</span> <span class="n">sessionTimeout</span><span class="o">,</span> <span class="k">this</span> <span class="o">);</span>
       <span class="c1">// 使用CountDownLatch.await()的线程（当前线程）阻塞直到所有其它拥有CountDownLatch的线程执行完毕（countDown()结果为0）</span>
       <span class="n">connectedSemaphore</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>          
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span> <span class="n">InterruptedException</span> <span class="n">e</span>  <span class="o">)</span> <span class="o">{</span>
       <span class="n">LOG</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"连接创建失败，发生 InterruptedException , e "</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>         
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span> <span class="n">IOException</span> <span class="n">e</span>  <span class="o">)</span> <span class="o">{</span>
       <span class="n">LOG</span><span class="o">.</span><span class="na">error</span><span class="o">(</span> <span class="s">"连接创建失败，发生 IOException , e "</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(),</span> <span class="n">e</span>  <span class="o">);</span>          
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<ol>
  <li>创建节点</li>
</ol>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/*
* 创建zNode节点, String create(path&lt;节点路径&gt;, data[]&lt;节点内容&gt;, List(ACL访问控制列表), CreateMode&lt;zNode创建类型&gt;)
*    节点创建类型(CreateMode)
*    1、PERSISTENT:持久化节点
*    2、PERSISTENT_SEQUENTIAL:顺序自动编号持久化节点，这种节点会根据当前已存在的节点数自动加 1
*    3、EPHEMERAL:临时节点客户端,session超时这类节点就会被自动删除
*    4、EPHEMERAL_SEQUENTIAL:临时自动编号节点
* @param path zNode节点路径
* @param data zNode数据内容
* @return 创建成功返回true, 反之返回false.
*/</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">createPath</span><span class="p">(</span> <span class="n">String</span> <span class="n">path</span><span class="o">,</span> <span class="n">String</span> <span class="n">data</span>  <span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
                    <span class="n">String</span> <span class="n">zkPath</span> <span class="o">=</span>  <span class="k">this</span><span class="o">.</span><span class="na">zk</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">path</span><span class="o">,</span> <span class="n">data</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(),</span> <span class="n">ZooDefs</span><span class="o">.</span><span class="na">Ids</span><span class="o">.</span><span class="na">OPEN_ACL_UNSAFE</span><span class="o">,</span> <span class="n">CreateMode</span><span class="o">.</span><span class="na">PERSISTENT</span><span class="o">);</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="na">info</span><span class="o">(</span> <span class="s">"节点创建成功, Path: "</span> <span class="o">+</span> <span class="n">zkPath</span> <span class="o">+</span> <span class="s">", content: "</span> <span class="o">+</span> <span class="n">data</span>  <span class="o">);</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span> <span class="n">KeeperException</span> <span class="n">e</span>  <span class="o">)</span> <span class="o">{</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="na">error</span><span class="o">(</span> <span class="s">"节点创建失败, 发生KeeperException! path: "</span> <span class="o">+</span> <span class="n">path</span> <span class="o">+</span> <span class="s">", data:"</span> <span class="o">+</span> <span class="n">data</span>
                                                 <span class="o">+</span> <span class="s">", errMsg:"</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(),</span> <span class="n">e</span> <span class="o">);</span>
                
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span> <span class="n">InterruptedException</span> <span class="n">e</span>  <span class="o">)</span> <span class="o">{</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="na">error</span><span class="o">(</span> <span class="s">"节点创建失败, 发生 InterruptedException! path: "</span> <span class="o">+</span> <span class="n">path</span> <span class="o">+</span> <span class="s">", data:"</span> <span class="o">+</span> <span class="n">data</span>
                                                 <span class="o">+</span> <span class="s">", errMsg:"</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(),</span> <span class="n">e</span> <span class="o">);</span>
                
    <span class="o">}</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        
<span class="o">}</span></code></pre></div>

<ol>
  <li>删除节点</li>
</ol>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/**
* &lt;p&gt;删除一个zMode节点, void delete(path&lt;节点路径&gt;, stat&lt;数据版本号&gt;)&lt;/p&gt;&lt;br/&gt;
* &lt;pre&gt;
*     说明
*     1、版本号不一致,无法进行数据删除操作.
*     2、如果版本号与znode的版本号不一致,将无法删除,是一种乐观加锁机制;如果将版本号设置为-1,不会去检测版本,直接删除.
* &lt;/pre&gt;
* @param path zNode节点路径
* @return 删除成功返回true,反之返回false.
*/</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">deletePath</span><span class="p">(</span> <span class="n">String</span> <span class="n">path</span>  <span class="o">){</span>
    <span class="k">try</span> <span class="o">{</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">zk</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">path</span><span class="o">,-</span><span class="mi">1</span><span class="o">);</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="na">info</span><span class="o">(</span> <span class="s">"节点删除成功, Path: "</span> <span class="o">+</span> <span class="n">path</span> <span class="o">);</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span> <span class="n">KeeperException</span> <span class="n">e</span>  <span class="o">)</span> <span class="o">{</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="na">error</span><span class="o">(</span> <span class="s">"节点删除失败, 发生KeeperException! path: "</span> <span class="o">+</span> <span class="n">path</span>
                                                 <span class="o">+</span> <span class="s">", errMsg:"</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(),</span> <span class="n">e</span> <span class="o">);</span>
                
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span> <span class="n">InterruptedException</span> <span class="n">e</span>  <span class="o">)</span> <span class="o">{</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="na">error</span><span class="o">(</span> <span class="s">"节点删除失败, 发生 InterruptedException! path: "</span> <span class="o">+</span> <span class="n">path</span>
                                                 <span class="o">+</span> <span class="s">", errMsg:"</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(),</span> <span class="n">e</span> <span class="o">);</span>
                
    <span class="o">}</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        
<span class="o">}</span></code></pre></div>

<ol>
  <li>节点赋值/更新节点</li>
</ol>

]]></content:encoded>
    </item>
    
    <item>
      <title>Apache Maven 使用指南</title>
      <link href="http://angelof7.github.io/maven-practice/"/>
      <pubDate>2015-07-27T00:00:00+08:00</pubDate>
      <author>andygc</author>
      <guid>http://angelof7.github.io/maven-practice</guid>
      <content:encoded><![CDATA[<h3 id="apache-maven">Apache Maven:</h3>
<hr />
<p>Maven 是一个项目管理和构建自动化工具。但是对于我们程序员来说，我们最关心的是它的项目构建功能。所以这里我们介绍的就是怎样用 maven 来满足我们项目的日常需要。
Maven 使用惯例优于配置的原则 。它要求在没有定制之前，所有的项目都有如下的结构:</p>

<table>
  <thead>
    <tr>
      <th>目录</th>
      <th>目的</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>${basedir}</td>
      <td>存放 pom.xml和所有的子目录</td>
    </tr>
    <tr>
      <td>${basedir}/src/main/java</td>
      <td>项目的 java源代码</td>
    </tr>
    <tr>
      <td>${basedir}/src/main/resources</td>
      <td>项目的资源，比如说 property文件</td>
    </tr>
    <tr>
      <td>${basedir}/src/test/java</td>
      <td>项目的测试类，比如说 JUnit代码</td>
    </tr>
    <tr>
      <td>${basedir}/src/test/resources</td>
      <td>测试使用的资源</td>
    </tr>
  </tbody>
</table>

<h3 id="maven-">Maven 的安装:</h3>
<p><a href="http://maven.apache.org/download.html">maven下载安装</a><br />
<code>$ mvn -v</code></p>

<h3 id="maven--1">Maven 的使用:</h3>
<ol>
  <li>archetype</li>
</ol>

<div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="gp">$ </span>mvn archetype:generate 
-DgroupId<span class="o">=</span>com.mycompany.helloworld 
-DartifactId<span class="o">=</span>helloworld 
-Dpackage<span class="o">=</span>com.mycompany.helloworld 
-Dversion<span class="o">=</span>1.0-SNAPSHOT</code></pre></div>

<ol>
  <li>构建</li>
</ol>

<div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="gp">$ </span>mvn clean compile   
<span class="gp">$ </span>mvn clean <span class="nb">test</span>   
<span class="gp">$ </span>mvn clean package  
<span class="gp">$ </span>mvn clean install</code></pre></div>

<ol>
  <li>POM</li>
</ol>

<div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;project</span> <span class="na">xmlns=</span><span class="s">"http://maven.apache.org/POM/4.0.0"</span> <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
     <span class="na">xsi:schemaLocation=</span><span class="s">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span><span class="nt">&gt;</span>
     <span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span> 

     <span class="nt">&lt;groupId&gt;</span>com.mycompany.helloworld<span class="nt">&lt;/groupId&gt;</span> 
     <span class="nt">&lt;artifactId&gt;</span>helloworld<span class="nt">&lt;/artifactId&gt;</span> 
     <span class="nt">&lt;version&gt;</span>1.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span> 
     <span class="nt">&lt;packaging&gt;</span>jar<span class="nt">&lt;/packaging&gt;</span> 

     <span class="nt">&lt;name&gt;</span>helloworld<span class="nt">&lt;/name&gt;</span> 
     <span class="nt">&lt;url&gt;</span>http://maven.apache.org<span class="nt">&lt;/url&gt;</span> 

     <span class="nt">&lt;properties&gt;</span> 
       <span class="nt">&lt;project.build.sourceEncoding&gt;</span>UTF-8<span class="nt">&lt;/project.build.sourceEncoding&gt;</span> 
     <span class="nt">&lt;/properties&gt;</span> 

     <span class="nt">&lt;dependencies&gt;</span>
       <span class="nt">&lt;dependency&gt;</span> 
         <span class="nt">&lt;groupId&gt;</span>junit<span class="nt">&lt;/groupId&gt;</span> 
         <span class="nt">&lt;artifactId&gt;</span>junit<span class="nt">&lt;/artifactId&gt;</span> 
         <span class="nt">&lt;version&gt;</span>3.8.1<span class="nt">&lt;/version&gt;</span> 
         <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span> 
       <span class="nt">&lt;/dependency&gt;</span> 
     <span class="nt">&lt;/dependencies&gt;</span> 
    <span class="nt">&lt;/project&gt;</span></code></pre></div>

<p>在 POM 中，groupId, artifactId, packaging, version 叫作 maven 坐标，它能唯一的确定一个项目。有了 maven 坐标，我们就可以用它来指定我们的项目所依赖的其他项目，插件，或者父项目。一般 maven 坐标写成如下的格式：<br />
<code>groupId:artifactId:packaging:version</code><br />
像我们的例子就会写成：<br />
<code>com.mycompany.helloworld: helloworld: jar: 1.0-SNAPSHOT</code></p>

<p>我们的 helloworld 示例很简单，但是大项目一般会分成几个子项目。在这种情况下，每个子项目就会有自己的 POM 文件，然后它们会有一个共同的父项目。这样只要构建父项目就能够构建所有的子项目了。子项目的 POM 会继承父项目的 POM。</p>

<ol>
  <li>scope
    <ul>
      <li>compile (默认)</li>
      <li>test</li>
      <li>provided (servlet-api)</li>
      <li>runtime (JDBC Driver)</li>
      <li>system</li>
      <li>import</li>
    </ul>
  </li>
  <li>
    <p>聚合和继承</p>
  </li>
  <li>
    <p>反应堆</p>
  </li>
  <li>常用命令</li>
</ol>

]]></content:encoded>
    </item>
    
    <item>
      <title>监控远程服务器JVM</title>
      <link href="http://angelof7.github.io/jvm-monitor-remote/"/>
      <pubDate>2015-07-20T00:00:00+08:00</pubDate>
      <author>andygc</author>
      <guid>http://angelof7.github.io/jvm-monitor-remote</guid>
      <content:encoded><![CDATA[<h3 id="section">远程服务器配置:</h3>
<hr />
<p>在tomcat中的bin/catalina.sh中添加:</p>

<div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">JAVA_OPTS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$JAVA_OPTS</span><span class="s2">  
 -Djava.rmi.server.hostname=nts3.photo.163.org  
 -Dcom.sun.management.jmxremote.port=8950  
 -Dcom.sun.management.jmxremote.authenticate=false  
 -Dcom.sun.management.jmxremote.ssl=false"</span></code></pre></div>

<h3 id="jconsole">JConsole</h3>
<hr />
<p><img src="/album/2015/jconsole.png" alt="jconsole.png" /></p>

<h3 id="visualvm">VisualVM</h3>
<hr />
<p><img src="/album/2015/jvisualvm.png" alt="jvisualvm.png" /></p>

<h3 id="section-1">参考</h3>
<p><a href="http://docs.oracle.com/javase/1.5.0/docs/guide/management/agent.html">Monitoring and Management Using JMX</a></p>

]]></content:encoded>
    </item>
    
    <item>
      <title>git协同工作流程</title>
      <link href="http://angelof7.github.io/work-with-git-branch/"/>
      <pubDate>2015-07-15T00:00:00+08:00</pubDate>
      <author>andygc</author>
      <guid>http://angelof7.github.io/work-with-git-branch</guid>
      <content:encoded><![CDATA[<p>本篇博客记录使用git协作的一般过程</p>

<h3 id="git">git工作流程</h3>
<hr />
<ol>
  <li>clone远程仓库:<br />
` $ git clone …
`</li>
  <li>去自己的分支工作:<br />
` $ git checkout work
`</li>
  <li>工作:<br />
` working ….
`</li>
  <li>提交工作分支的修改:<br />
` $ git add . ` 
` $ git commit -a `</li>
  <li>回到主分支:<br />
` $ git checkout master
`</li>
  <li>获取最新的修改: <br />
` $ git pull origin master
`</li>
  <li>回到工作分支:<br />
` $ git checkout work
`</li>
  <li>合并主分支,并修改冲突:<br />
` $ git rebase master
`</li>
  <li>回到主分支:<br />
` $ git checkout master
`</li>
  <li>合并工作分支的修改,此时不会发生冲突了:<br />
` $ git merge work
`</li>
  <li>提交到远程:<br />
` $ git push origin master
`</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>LinkedHashMap源码分析与LRU实现</title>
      <link href="http://angelof7.github.io/implementation-of-LinkedHashMap-and-LRU-implementation/"/>
      <pubDate>2015-07-13T00:00:00+08:00</pubDate>
      <author>andygc</author>
      <guid>http://angelof7.github.io/implementation-of-LinkedHashMap-and-LRU-implementation</guid>
      <content:encoded><![CDATA[<p>LinkedHashMap可认为是哈希表和链接列表综合实现，并允许使用null值和null键。LinkedHashMap实现与HashMap的不同之处在于，LinkedHashMap维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。
LinkedHashMap的实现不是同步的。如果多个线程同时访问LinkedHashMap，而其中至少一个线程从结构上修改了该映射，则它必须
保持外部同步。</p>

<h2 id="linkedhashmap">1.LinkedHashMap的存储结构</h2>

<p><img src="http://stackvoid.qiniudn.com/20140805-LinkedHashMapDataStructure01.png" alt="LinkedHashMap01" />
LinkedHashMap中加入了一个head头结点，将所有插入到该LinkedHashMap中的Entry按照插入的先后顺序（accessOrder标志位默认为false）依次加入到以head为头结点的双向循环链表的尾部。</p>

<p>LinkedHashMap实际上就是HashMap和LinkedList两个集合类的存储结构的结合。在LinkedHashMapMap中，所有put进来的Entry都保存在
如图所示的哈希表中，但它又额外定义了一个以head为头结点的空的双向循环链表，每次put进来Entry，除了将其保存到对哈希表中对应的位置上外，还要将其插入到双向循环链表的尾部。</p>

<p>下面我们来分析LinkedHashMap的源代码。</p>

<h2 id="linkedhashmap-1">2.LinkedHashMap成员变量</h2>

<p>LinkedHashMap采用的hash算法和HashMap相同，但它重新定义了数组中保存的元素Entry，该Entry除了保存当前对象的引用外，还保
存了其上一个元素before和下一个元素after的引用，从而在哈希表的基础上又构成了双向链接列表。</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//双向循环链表的头结点，整个LinkedHashMap中只有一个header，</span>
<span class="c1">//（此链表不同于HashMap里面的那个next链表）</span>
<span class="c1">//它将哈希表中所有的Entry贯穿起来，header中不保存key-value对，只保存前后节点的引用</span>
   <span class="kd">private</span> <span class="kd">transient</span> <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">header</span><span class="o">;</span>

<span class="c1">//双向链表中元素排序规则的标志位。</span>
<span class="c1">//accessOrder为false，表示按插入顺序排序</span>
<span class="c1">//accessOrder为true，表示按访问顺序排序</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">accessOrder</span><span class="o">;</span>


 <span class="cm">/** 
 * LinkedHashMap的Entry元素。 
 * 继承HashMap的Entry元素，又保存了其上一个元素before和下一个元素after的引用。 
 */</span>  
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">HashMap</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>  
    <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">before</span><span class="o">,</span> <span class="n">after</span><span class="o">;</span>  
    <span class="err">……</span>  <span class="c1">//Entry类涉及到的方法，下面会继续分析</span>
<span class="o">}</span></code></pre></div>

<h2 id="section">3.构造函数</h2>

<p>LinkedList一共提供了五个构造方法。</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 构造方法1，构造一个指定初始容量和加载因子的、按照插入顺序的LinkedList</span>
<span class="c1">//加载因子取默认的0.75f  </span>

<span class="kd">public</span> <span class="nf">LinkedHashMap</span><span class="p">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">,</span> <span class="n">loadFactor</span><span class="o">);</span>
    <span class="n">accessOrder</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 构造方法2，构造一个指定初始容量的LinkedHashMap，取得键值对的顺序是插入顺序</span>
<span class="c1">//加载因子取默认的0.75f  </span>

<span class="kd">public</span> <span class="nf">LinkedHashMap</span><span class="p">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">);</span>
    <span class="n">accessOrder</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 构造方法3，用默认的初始化容量和加载因子创建一个LinkedHashMap，取得键值对的顺序是插入顺序</span>
<span class="c1">//加载因子取默认的0.75f  </span>

<span class="kd">public</span> <span class="nf">LinkedHashMap</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">();</span>
    <span class="n">accessOrder</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 构造方法4，通过传入的map创建一个LinkedHashMap，容量为默认容量（16）和</span>
<span class="c1">//(map.zise()/DEFAULT_LOAD_FACTORY)+1的较大者，加载因子为默认值0.75</span>

<span class="kd">public</span> <span class="nf">LinkedHashMap</span><span class="p">(</span><span class="n">Map</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>
    <span class="n">accessOrder</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 构造方法5，根据指定容量、加载因子和指定链表中的元素排序的规则  创建一个LinkedHashMap</span>
<span class="kd">public</span> <span class="nf">LinkedHashMap</span><span class="p">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span>
             <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">,</span>
                         <span class="kt">boolean</span> <span class="n">accessOrder</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">,</span> <span class="n">loadFactor</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">accessOrder</span> <span class="o">=</span> <span class="n">accessOrder</span><span class="o">;</span>
<span class="o">}</span></code></pre></div>

<p>我们已经知道LinkedHashMap的Entry元素继承HashMap的Entry，提供了双向链表的功能。在HashMap的构造器中，最后会调用init()方法，进行相关的初始化，这个方法在HashMap的实现中是空方法(感叹模板模式的精妙！)，只是提供给子类实现相关的初始化调用。LinkedHashMap重写了init()方法，在调用父类的构造方法完成构造后，进一步实现了对其元素Entry的初始化操作。分析init()方法，的确是对header进行了初始化，并构造成一个双向循环链表（和LinkedList的存储结构是一样的）。</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">header</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;(-</span><span class="mi">1</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="n">header</span><span class="o">.</span><span class="na">before</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="na">after</span> <span class="o">=</span> <span class="n">header</span><span class="o">;</span>
<span class="o">}</span></code></pre></div>

<h2 id="section-1">4.元素存储</h2>

<p>LinkedHashMap重写了父类HashMap的put方法调用的<strong>子方法void addEntry(int hash, K key, V value, int bucketIndex) 和void createEntry(int hash, K key, V value, int bucketIndex)</strong>，提供了自己特有的双向链接列表的实现。</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//覆写HashMap中的addEntry方法，LinkedHashmap并没有覆写HashMap中的put方法，</span>
	<span class="c1">//而是覆写了put方法所调用的addEntry方法和recordAccess方法，</span>
	<span class="c1">//put方法在插入的key已存在的情况下，会调用recordAccess方法，</span>
	<span class="c1">//在插入的key不存在的情况下，要调用addEntry插入新的Entry</span>
<span class="kt">void</span> <span class="nf">addEntry</span><span class="p">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bucketIndex</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">//创建新的Entry，并插入到LinkedHashMap中</span>
    <span class="n">createEntry</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">bucketIndex</span><span class="o">);</span>

    <span class="c1">//双向链表的第一个有效节点（header后的那个节点）为近期最少使用的节点</span>
    <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">eldest</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="na">after</span><span class="o">;</span>
    <span class="c1">//如果有必要，则删除掉该近期最少使用的节点，</span>
	<span class="c1">//这要看对removeEldestEntry的覆写,由于默认为false，因此默认是不做任何处理的。</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">removeEldestEntry</span><span class="o">(</span><span class="n">eldest</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">removeEntryForKey</span><span class="o">(</span><span class="n">eldest</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    	<span class="c1">//超过阈值，扩容到原来的2倍</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="o">)</span>
            <span class="n">resize</span><span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">table</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">createEntry</span><span class="p">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bucketIndex</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">HashMap</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">old</span> <span class="o">=</span> <span class="n">table</span><span class="o">[</span><span class="n">bucketIndex</span><span class="o">];</span>
    <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">old</span><span class="o">);</span>
    <span class="n">table</span><span class="o">[</span><span class="n">bucketIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
    <span class="c1">// 调用元素的addBrefore方法，将元素加入到哈希、双向链接列表。</span>
    <span class="c1">//每次插入Entry时，都将其移到双向链表的尾部，</span>
	<span class="c1">//这便会按照Entry插入LinkedHashMap的先后顺序来迭代元素，</span>
	<span class="c1">//同时，新put进来的Entry是最近访问的Entry，把其放在链表末尾，符合LRU算法的实现</span>
    <span class="n">e</span><span class="o">.</span><span class="na">addBefore</span><span class="o">(</span><span class="n">header</span><span class="o">);</span>
    <span class="n">size</span><span class="o">++;</span>
<span class="o">}</span>
<span class="c1">//双向循环立链表中，将当前的Entry插入到existingEntry的前面</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">addBefore</span><span class="p">(</span><span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">existingEntry</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">after</span>  <span class="o">=</span> <span class="n">existingEntry</span><span class="o">;</span>
    <span class="n">before</span> <span class="o">=</span> <span class="n">existingEntry</span><span class="o">.</span><span class="na">before</span><span class="o">;</span>
    <span class="n">before</span><span class="o">.</span><span class="na">after</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
    <span class="n">after</span><span class="o">.</span><span class="na">before</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">//该方法默认返回false，我们一般在用LinkedHashMap实现LRU算法时，</span>
<span class="c1">//要覆写该方法，一般的实现是，当设定的内存（这里指节点个数）达到最大值时，返回true，</span>
<span class="c1">//这样put新的Entry（该Entry的key在哈希表中没有已经存在）时，</span>
<span class="c1">//就会调用removeEntryForKey方法，将最近最少使用的节点删除（head后面的那个节点，实际上是最近没有使用）。</span>
    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="n">removeEldestEntry</span><span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">eldest</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<h2 id="section-2">5.元素读取</h2>

<p>LinkedHashMap重写了父类HashMap的get方法。由于的链表的增加、删除操作是常量级的，性能不会带来较大损失。LinkedHashMap
最牛逼的地方在于<strong>recordAccess()</strong>方法</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//覆写HashMap中的get方法，通过getEntry方法获取Entry对象。</span>
	<span class="c1">//注意这里的recordAccess方法，</span>
	<span class="c1">//如果链表中元素的排序规则是按照插入的先后顺序排序的话，该方法什么也不做，</span>
	<span class="c1">//如果链表中元素的排序规则是按照访问的先后顺序排序的话，则将e移到链表的末尾处。</span>
<span class="kd">public</span> <span class="n">V</span> <span class="nf">get</span><span class="p">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 调用父类HashMap的getEntry()方法，取得要查找的元素。</span>
    <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">getEntry</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="c1">// 记录访问顺序。</span>
    <span class="n">e</span><span class="o">.</span><span class="na">recordAccess</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">//覆写HashMap中的recordAccess方法（HashMap中该方法为空），</span>
<span class="c1">//当调用父类的put方法，在发现插入的key已经存在时，会调用该方法，</span>
<span class="c1">//调用LinkedHashmap覆写的get方法时，也会调用到该方法，</span>
<span class="c1">//该方法提供了LRU算法的实现，它将最近使用的Entry放到双向循环链表的尾部，</span>
<span class="c1">//accessOrder为true时，get方法会调用recordAccess方法</span>
<span class="c1">//put方法在覆盖key-value对时也会调用recordAccess方法</span>
<span class="c1">//它们导致Entry最近使用，因此将其移到双向链表的末尾</span>
<span class="kt">void</span> <span class="nf">recordAccess</span><span class="p">(</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">lm</span> <span class="o">=</span> <span class="o">(</span><span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">m</span><span class="o">;</span>
	<span class="c1">//如果链表中元素按照访问顺序排序，则将当前访问的Entry移到双向循环链表的尾部，</span>
	<span class="c1">//如果是按照插入的先后顺序排序，则不做任何事情。</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">lm</span><span class="o">.</span><span class="na">accessOrder</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">lm</span><span class="o">.</span><span class="na">modCount</span><span class="o">++;</span>
        <span class="n">remove</span><span class="o">();</span><span class="c1">//移除当前访问的Entry</span>
        <span class="n">addBefore</span><span class="o">(</span><span class="n">lm</span><span class="o">.</span><span class="na">header</span><span class="o">);</span><span class="c1">//将当前访问的Entry插入到链表的尾部</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<h2 id="section-3">6.元素删除</h2>

<p>LinkedHashMap没有重写remove(Object key)方法，重写了被remove调用的recordRemoval方法，再一次感叹模板方法模式的精妙！<br />
HahsMap remove(Object key)把数据从横向数组 * 竖向next链表里面移除之后（就已经完成工作了，所以HashMap里面recordRemoval是空的实现调用了此方法<br />
但在LinkedHashMap里面，还需要移除header链表里面Entry的after和before关系。</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 继承了HashMap.Entry  </span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">HashMap</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>  
 
    <span class="kt">void</span> <span class="n">recordRemoval</span><span class="o">(</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>  
        <span class="n">remove</span><span class="o">();</span>  
    <span class="o">}</span>  
      
    <span class="c1">//让当前Entry从header链表中消失  </span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="n">remove</span><span class="o">()</span> <span class="o">{</span>  
        <span class="n">before</span><span class="o">.</span><span class="na">after</span> <span class="o">=</span> <span class="n">after</span><span class="o">;</span>  
        <span class="n">after</span><span class="o">.</span><span class="na">before</span> <span class="o">=</span> <span class="n">before</span><span class="o">;</span>  
    <span class="o">}</span>  
<span class="o">}</span></code></pre></div>

<h2 id="section-4">7.元素遍历</h2>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//迭代器</span>
    <span class="kd">private</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">LinkedHashIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">nextEntry</span>    <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="na">after</span><span class="o">;</span>
        <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">lastReturned</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

        <span class="cm">/**
         * The modCount value that the iterator believes that the backing
         * List should have.  If this expectation is violated, the iterator
         * has detected concurrent modification.
         */</span>
        <span class="kt">int</span> <span class="n">expectedModCount</span> <span class="o">=</span> <span class="n">modCount</span><span class="o">;</span>

        <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">hasNext</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">nextEntry</span> <span class="o">!=</span> <span class="n">header</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="n">remove</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lastReturned</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">modCount</span> <span class="o">!=</span> <span class="n">expectedModCount</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">ConcurrentModificationException</span><span class="o">();</span>

            <span class="n">LinkedHashMap</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">lastReturned</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
            <span class="n">lastReturned</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">expectedModCount</span> <span class="o">=</span> <span class="n">modCount</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//从head的下一个节点开始迭代</span>
        <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">nextEntry</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">modCount</span> <span class="o">!=</span> <span class="n">expectedModCount</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">ConcurrentModificationException</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nextEntry</span> <span class="o">==</span> <span class="n">header</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">NoSuchElementException</span><span class="o">();</span>

            <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">lastReturned</span> <span class="o">=</span> <span class="n">nextEntry</span><span class="o">;</span>
            <span class="n">nextEntry</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">after</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">//key迭代器</span>
    <span class="c1">//看出这三个类都很简单，只有一个next()方法，next()方法也只是去调用LinkedHashIterator类中相应的方法</span>
    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">KeyIterator</span> <span class="kd">extends</span> <span class="n">LinkedHashIterator</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="n">K</span> <span class="n">next</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">nextEntry</span><span class="o">().</span><span class="na">getKey</span><span class="o">();</span> <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">//value迭代器</span>
    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">ValueIterator</span> <span class="kd">extends</span> <span class="n">LinkedHashIterator</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="n">V</span> <span class="n">next</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">nextEntry</span><span class="o">().</span><span class="na">value</span><span class="o">;</span> <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">//Entry迭代器</span>
    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">EntryIterator</span> <span class="kd">extends</span> <span class="n">LinkedHashIterator</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">nextEntry</span><span class="o">();</span> <span class="o">}</span>
    <span class="o">}</span></code></pre></div>

<h2 id="linkedhashmaplru-cache">8.基于LinkedHashMap实现LRU Cache</h2>

<p>用LinkedHashmap实现LRU算法，就要覆写方法removeEldestEntry。该方法默认返回false，我们一般在用LinkedHashMap实现LRU算法时，要覆写该方法，一般的实现是，当设定的内存（这里指节点个数）达到最大值时，返回true，这样put新的Entry（该Entry的key在哈希表中没有已经存在）时，就会调用removeEntryForKey方法，将最近最少使用的节点删除（head后面的那个节点，实际上是最近没有使用）。</p>

<p>LinkedHashMap是如何实现LRU的。首先，当accessOrder为true时，才会开启按访问顺序排序的模式，才能用来实现LRU算法。我们
可以看到，无论是put方法还是get方法，都会导致目标Entry成为最近访问的Entry，因此便把该Entry加入到了双向链表的末尾（
get方法通过调用recordAccess方法来实现，put方法在覆盖已有key的情况下，也是通过调用recordAccess方法来实现，在插入新的Entry时，则是通过createEntry中的addBefore方法来实现），这样便把最近使用了的Entry放入到了双向链表的后面，多次操作后，
双向链表前面的Entry便是最近没有使用的，这样当节点个数满的时候，删除的最前面的Entry(head后面的那个Entry)便是最近最少使用的Entry。</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/*LRU是Least Recently Used 近期最少使用算法。
 *通过HashLiekedMap实现LRU的算法的关键是，如果map里面的元素个数大于了缓存最大容量，则删除链表头元素
 */</span>

<span class="cm">/*public LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder)
 *LRU参数参数：
 *initialCapacity - 初始容量。
 *loadFactor - 加载因子（需要是按该因子扩充容量）。
 *accessOrder - 排序模式( true) - 对于访问顺序（get一个元素后，这个元素被加到最后，使用了LRU  最近最少被使用的调度算法），对于插入顺序，则为 false,可以不断加入元素。
 */</span>

 <span class="cm">/*相关思路介绍：
  * 当有一个新的元素加入到链表里面时，程序会调用LinkedHahMap类中Entry的addEntry方法，
  *而该方法又会 会调用removeEldestEntry方法，这里就是实现LRU元素过期机制的地方，
  * 默认的情况下removeEldestEntry方法只返回false，表示可以一直表链表里面增加元素，在这个里  *修改一下就好了。 
  *
  */</span>
 
<span class="cm">/*
测试数据：
11
7 0 7 1 0 1 2 1 2 6
*/</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LRULinkedHashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;{</span>     
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>                     <span class="c1">//初始内存容量</span>
    
    <span class="n">LRULinkedHashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">){</span>          <span class="c1">//构造方法，传入一个参数</span>
        <span class="kd">super</span><span class="o">(</span><span class="mi">16</span><span class="o">,</span><span class="mf">0.75f</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>               <span class="c1">//调用LinkedHashMap，传入参数    </span>
        <span class="k">this</span><span class="o">.</span><span class="na">capacity</span><span class="o">=</span><span class="n">capacity</span><span class="o">;</span>             <span class="c1">//传递指定的最大内存容量</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">removeEldestEntry</span><span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">eldest</span><span class="o">){</span>     
        <span class="c1">//，每加入一个元素，就判断是size是否超过了已定的容量</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"此时的size大小="</span><span class="o">+</span><span class="n">size</span><span class="o">());</span>
        <span class="k">if</span><span class="o">((</span><span class="n">size</span><span class="o">()&gt;</span><span class="n">capacity</span><span class="o">))</span>
        <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"超出已定的内存容量，把链表顶端元素移除："</span><span class="o">+</span><span class="n">eldest</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">size</span><span class="o">()&gt;</span><span class="n">capacity</span><span class="o">;</span>        
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span><span class="o">{</span><span class="c1">//方便实例，直接将异常抛出</span>
        <span class="n">Scanner</span> <span class="n">cin</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scanner</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
        
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"请输入总共内存页面数： "</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cin</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="n">LRULinkedHashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;(</span><span class="n">n</span><span class="o">);</span>
        
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"请输入按顺序输入要访问内存的总共页面数： "</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">cin</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"请输入按顺序输入访问内存的页面序列： "</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">y</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span>
        <span class="o">{</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">cin</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">x</span><span class="o">,</span>  <span class="n">x</span><span class="o">);</span>  
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"此时内存中包含的页面数是有:"</span><span class="o">);</span>
        <span class="c1">//遍历此时内存中的页面并输出</span>
        <span class="k">for</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="nl">entry:</span> <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">()){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<h2 id="section-5">9.总结</h2>

<ol>
  <li>
    <p>LinkedHashMap继承自HashMap，具有HashMap的大部分特性，比如支持null键和值，默认容量为16，装载因子为0.75，非线程安全等等；</p>
  </li>
  <li>
    <p>LinkedHashMap通过设置accessOrder控制遍历顺序是按照插入顺序还是按照访问顺序。当accessOrder为true时，可以利用其完成LRU缓存的功能；</p>
  </li>
  <li>
    <p>LinkedHashMap内部维护了一个双向循环链表，并且其迭代操作时通过链表完成的，而不是去遍历hash表。</p>
  </li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>Mac &amp; Ubuntu 配置openvpn客户端</title>
      <link href="http://angelof7.github.io/mac-ubuntu-openvpn/"/>
      <pubDate>2015-07-02T00:00:00+08:00</pubDate>
      <author>andygc</author>
      <guid>http://angelof7.github.io/mac-ubuntu-openvpn</guid>
      <content:encoded><![CDATA[<h2 id="mac">Mac</h2>
<hr />
<p><strong>tunnelblick</strong></p>

<h2 id="ubuntu">Ubuntu</h2>
<hr />
<ol>
  <li>
    <blockquote>
      <p># sudo apt-get install openvpn</p>
    </blockquote>
  </li>
  <li>
    <blockquote>
      <p># cd /etc/openvpn</p>
    </blockquote>
  </li>
  <li>
    <blockquote>
      <p># cp ~/Downloads/client.ovpn .</p>
    </blockquote>
  </li>
  <li>
    <blockquote>
      <p># sudo openvpn /etc/openvpn/client.ovpn</p>
    </blockquote>
  </li>
  <li>
    <p>后台连接:<br />
&gt;# sudo openvpn /etc/openvpn/client.ovpn &gt; /dev/null &amp;</p>
  </li>
  <li>开机启动:<br />
将上述命令加入:
&gt; /etc/rc.local</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>git clone后没有代码</title>
      <link href="http://angelof7.github.io/git-clone-empty/"/>
      <pubDate>2015-06-24T00:00:00+08:00</pubDate>
      <author>andygc</author>
      <guid>http://angelof7.github.io/git-clone-empty</guid>
      <content:encoded><![CDATA[<p>用git clone 下载项目后，目录中只有.git目录</p>

<h2 id="section">原因</h2>
<hr />
<p>这个repository中存在多个分支下载的这个分支是个bare repository</p>

<h2 id="section-1">解决方法</h2>
<hr />
<ol>
  <li>
    <p>查看远程分支：
&gt; git branch -r -a</p>
  </li>
  <li>
    <p>checkout：
&gt; git checkout branch_name</p>
  </li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>Linux中常用系统管理shell命令</title>
      <link href="http://angelof7.github.io/linux-shell-system/"/>
      <pubDate>2015-05-30T00:00:00+08:00</pubDate>
      <author>andygc</author>
      <guid>http://angelof7.github.io/linux-shell-system</guid>
      <content:encoded><![CDATA[<p>本篇博客记录常用的Linux系统管理shell</p>

<h3 id="ps">ps</h3>
<hr />
<ol>
  <li>ps 的参数说明
 l       长格式输出； 
 u       按用户名和启动时间的顺序来显示进程； 
 j       用任务格式来显示进程； 
 f       用树形格式来显示进程； 
 a       显示所有用户的所有进程（包括其它用户）；<br />
 x       显示无控制终端的进程；<br />
 r       显示运行中的进程；<br />
 ww      避免详细参数被截断；<br />
<em>我们常用的选项是组合是aux -ef 输出的解释；</em>  <br />
 USER    进程的属主；<br />
 PID     进程的ID；<br />
 PPID    父进程；<br />
 %CPU    进程占用的CPU百分比；<br />
 %MEM    占用内存的百分比；<br />
 NI      进程的NICE值，数值大，表示较少占用CPU时间；<br />
 VSZ     进程虚拟大小；<br />
 RSS     驻留中页的数量；<br />
 WCHAN   正在等待的进程资源 <br />
 TTY     终端ID  <br />
 STAT    进程状态 <br />
 START   启动进程的时间；
 TIME    进程消耗CPU的时间；<br />
 COMMAND 命令的名称和参数；<br />
<em>实例</em>
 &gt; ps -aux | more<br />
 &gt; ps -aux &gt; ps001.txt<br />
 &gt; ps aux | grep httpd <br />
 &gt; ps auxf |grep httpd<br />
pgrep 是通过程序的名字来查询进程的工具，一般是用来判断程序是否正在运行: <br />
常用参数:<br />
 -l      列出程序名和进程ID；<br />
 -o      进程起始的ID；<br />
 -n      进程终止的ID；<br />
 &gt; pgrep -l httpd</li>
</ol>

<h3 id="kill">kill</h3>
<hr />
<p>####kill<br />
kill的应用是和ps 或pgrep 命令结合在一起使用的；<br />
<em>用法</em>  <br />
kill ［信号代码］   进程ID<br />
注：信号代码可以省略；我们常用的信号代码是 -9 ，表示强制终止；</p>

<h4 id="killall">killall</h4>
<p>killall 通过程序的名字，直接杀死所有进程，咱们简单说一下就行了。<br />
<em>用法</em><br />
killall 正在运行的程序名  <br />
killall 也和ps或pgrep 结合使用，比较方便；通过ps或pgrep 来查看哪些程序在运行；<br />
<em>举例</em><br />
 &gt;  [root@localhost beinan]# pgrep -l gaim<br />
 &gt;  2979 gaim<br />
 &gt;  [root@localhost beinan]# killall gaim</p>

<h4 id="pkill">pkill</h4>
<p>pkill 和killall 应用方法差不多，也是直接杀死运行中的程序；如果您想杀掉单个进程，请用kill 来杀掉。<br />
<em>用法</em><br />
pkill 正在运行的程序名<br />
<em>举例</em><br />
&gt;  [root@localhost beinan]# pgrep -l gaim</p>

<blockquote>
  <p>2979 gaim</p>
</blockquote>

<blockquote>
  <p>[root@localhost beinan]# pkill gaim</p>
</blockquote>

<h4 id="xkill">xkill</h4>
<p>xkill 是在桌面用的杀死图形界面的程序。比如当firefox 出现崩溃不能退出时，点鼠标就能杀死firefox 。当xkill运行时出来和个人脑骨的图标，哪个图形程序崩溃一点就OK了。如果您想终止xkill ，就按右键取消；
<em>用法</em><br />
&gt;  [root@localhost ~]# xkill</p>

<h3 id="top">top</h3>
<hr />
<p>TOP是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定.</p>

<p>total 进程总数<br />
running 正在运行的进程数<br />
sleeping 睡眠的进程数<br />
stopped 停止的进程数<br />
zombie 僵尸进程数<br />
Cpu(s): <br />
0.3% us 用户空间占用CPU百分比<br />
1.0% sy 内核空间占用CPU百分比<br />
0.0% ni 用户进程空间内改变过优先级的进程占用CPU百分比<br />
98.7% id 空闲CPU百分比<br />
0.0% wa 等待输入输出的CPU时间百分比<br />
0.0%hi：硬件CPU中断占用百分比<br />
0.0%si：软中断占用百分比<br />
0.0%st：虚拟机占用百分比</p>

<p>Mem:<br />
191272k total    物理内存总量<br />
173656k used    使用的物理内存总量<br />
17616k free    空闲内存总量<br />
22052k buffers    用作内核缓存的内存量<br />
Swap: <br />
192772k total    交换区总量<br />
0k used    使用的交换区总量<br />
192772k free    空闲交换区总量<br />
123988k cached    缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小,相应的内存再次被换出时可不必再对交换区写入。</p>

<p>序号  列名    含义<br />
a    PID     进程id<br />
b    PPID    父进程id<br />
c    RUSER   Real user name<br />
d    UID     进程所有者的用户id<br />
e    USER    进程所有者的用户名<br />
f    GROUP   进程所有者的组名<br />
g    TTY     启动进程的终端名。不是从终端启动的进程则显示为 ?<br />
h    PR      优先级<br />
i    NI      nice值。负值表示高优先级，正值表示低优先级<br />
j    P       最后使用的CPU，仅在多CPU环境下有意义<br />
k    %CPU    上次更新到现在的CPU时间占用百分比<br />
l    TIME    进程使用的CPU时间总计，单位秒<br />
m    TIME+   进程使用的CPU时间总计，单位1/100秒<br />
n    %MEM    进程使用的物理内存百分比<br />
o    VIRT    进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES<br />
p    SWAP    进程使用的虚拟内存中，被换出的大小，单位kb。<br />
q    RES     进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA<br />
r    CODE    可执行代码占用的物理内存大小，单位kb<br />
s    DATA    可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb<br />
t    SHR     共享内存大小，单位kb<br />
u    nFLT    页面错误次数<br />
v    nDRT    最后一次写入到现在，被修改过的页面数。<br />
w    S       进程状态(D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程)<br />
x    COMMAND 命令名/命令行<br />
y    WCHAN   若该进程在睡眠，则显示睡眠中的系统函数名<br />
z    Flags   任务标志，参考 sched.h</p>

<h4 id="top-1">top使用格式:</h4>
<blockquote>
  <p>top [-] [d] [p] [q] [c] [C] [S] [s]  [n]</p>
</blockquote>

<p>d 指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。 
p 通过指定监控进程ID来仅仅监控某个进程的状态。 
q 该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。 
S 指定累计模式 
s 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。 
i 使top不显示任何闲置或者僵死进程。 
c 显示整个命令行而不只是显示命令名</p>

<p>Ctrl+L 擦除并且重写屏幕。</p>

<p>h或者? 显示帮助画面，给出一些简短的命令总结说明。</p>

<p>k 终止一个进程。系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。</p>

<p>i 忽略闲置和僵死进程。这是一个开关式命令。</p>

<p>q 退出程序。</p>

<p>r 重新安排一个进程的优先级别。系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。</p>

<p>S 切换到累计模式。</p>

<p>s 改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。</p>

<p>f或者F 从当前显示中添加或者删除项目。</p>

<p>o或者O 改变显示项目的顺序。</p>

<p>l 切换显示平均负载和启动时间信息。</p>

<p>m 切换显示内存信息。</p>

<p>t 切换显示进程和CPU状态信息。</p>

<p>c 切换显示命令名称和完整命令行。</p>

<p>M 根据驻留内存大小进行排序。</p>

<p>P 根据CPU使用百分比大小进行排序。</p>

<p>T 根据时间/累计时间进行排序。</p>

<p>W 将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。</p>

<h3 id="free">free</h3>
<hr />
<p>free命令由procps.*.rpm提供（在Redhat系列的OS上）。free命令的所有输出值都是从/proc/meminfo中读出的。</p>

<h3 id="section">系统</h3>
<hr />
<pre><code># uname -a # 查看内核/操作系统/CPU信息  
# head -n 1 /etc/issue # 查看操作系统版本  
# cat /proc/cpuinfo # 查看CPU信息    
# hostname # 查看计算机名  
# lspci -tv # 列出所有PCI设备  
# lsusb -tv # 列出所有USB设备  
# lsmod # 列出加载的内核模块  
# env # 查看环境变量  
</code></pre>

<h3 id="section-1">资源</h3>
<hr />
<pre><code># free -m # 查看内存使用量和交换区使用量  
# df -h # 查看各分区使用情况   
# du -sh &lt;目录名&gt; # 查看指定目录的大小  
# grep MemTotal /proc/meminfo # 查看内存总量  
# grep MemFree /proc/meminfo # 查看空闲内存量  
# uptime # 查看系统运行时间、用户数、负载  
# cat /proc/loadavg # 查看系统负载  
</code></pre>

<h3 id="section-2">磁盘和分区</h3>
<hr />
<pre><code># mount | column -t # 查看挂接的分区状态  
# fdisk -l # 查看所有分区  
# swapon -s # 查看所有交换分区  
# hdparm -i /dev/hda # 查看磁盘参数（仅适用于IDE设备）  
# dmesg | grep IDE # 查看启动时IDE设备检测状况  
</code></pre>

<h3 id="section-3">网络</h3>
<hr />
<pre><code># ifconfig # 查看所有网络接口的属性  
# iptables -L # 查看防火墙设置  
# route -n # 查看路由表  
# netstat -lntp # 查看所有监听端口  
# netstat -antp # 查看所有已经建立的连接  
# netstat -s # 查看网络统计信息  
</code></pre>

<h3 id="section-4">进程</h3>
<hr />
<pre><code># ps -ef # 查看所有进程  
# top # 实时显示进程状态  
</code></pre>

<h3 id="section-5">用户</h3>
<hr />
<pre><code># w # 查看活动用户  
# id &lt;用户名&gt; # 查看指定用户信息  
# last # 查看用户登录日志  
# cut -d: -f1 /etc/passwd # 查看系统所有用户  
# cut -d: -f1 /etc/group # 查看系统所有组  
# crontab -l # 查看当前用户的计划任务  
</code></pre>

<h3 id="section-6">服务</h3>
<hr />
<pre><code># chkconfig --list # 列出所有系统服务  
# chkconfig --list | grep on # 列出所有启动的系统服务  
</code></pre>

<h3 id="section-7">程序</h3>
<hr />
<pre><code># rpm -qa # 查看所有安装的软件包  
</code></pre>

]]></content:encoded>
    </item>
    
    <item>
      <title>在CentOS服务器中创建Git仓库并同步网站</title>
      <link href="http://angelof7.github.io/CentOS-git-hooks/"/>
      <pubDate>2015-05-26T00:00:00+08:00</pubDate>
      <author>andygc</author>
      <guid>http://angelof7.github.io/CentOS-git-hooks</guid>
      <content:encoded><![CDATA[<p>本篇博客记录在CentOS服务器中部署Git仓库，并同步apache中的网站目录的过程</p>

<h3 id="git">搭建Git服务器</h3>
<hr />
<ol>
  <li>
    <p>安装git</p>
  </li>
  <li>
    <p>创建一个git用户:
&gt; sudo adduser git</p>
  </li>
  <li>
    <p>创建证书登陆:
收集所有需要登录的用户的公钥（id_rsa.pub），把所有公钥导入到~/.ssh/authorized_keys文件中，一行一个</p>
  </li>
  <li>
    <p>初始化git仓库:
&gt; sudo git init –bare test.git</p>
  </li>
</ol>

<blockquote>
  <p>sudo chown -R git:git test.git</p>
</blockquote>

<ol>
  <li>禁用git用户的Shell登陆:
修改/etc/passwd中的
&gt; git:x:1001:1001:,,,:/home/git:/bin/bash</li>
</ol>

<p>改为：</p>

<blockquote>
  <p>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</p>
</blockquote>

<ol>
  <li>构建Hook:
&gt; cd test.git</li>
</ol>

<blockquote>
  <p>cat &gt; hooks/post-receive</p>
</blockquote>

<p>#!/bin/bash</p>

<p>GIT_WORK_TREE=/var/www/blog git checkout -f</p>

<blockquote>
  <p>chmod +x hooks/post-receive</p>
</blockquote>

<h3 id="clone">本地clone并推送</h3>
<hr />
<ol>
  <li>
    <p>cd work</p>
  </li>
  <li>
    <p>git clone git@server_address:/root/test/test.git</p>
  </li>
  <li>
    <p>cd test</p>
  </li>
  <li>
    <p>touch README.md</p>
  </li>
  <li>
    <p>git add .</p>
  </li>
  <li>
    <p>git commit -m “initial commit”</p>
  </li>
  <li>
    <p>git push origin master</p>
  </li>
</ol>

<h3 id="section">二级域名</h3>
<hr />
<ol>
  <li>
    <p><a href="http://jingyan.baidu.com/article/b24f6c82db5ecc86bfe5dae7.html">万网设置</a></p>
  </li>
  <li>
    <p>Apache设置</p>
  </li>
</ol>

<div class="highlight"><pre><code class="language-xml" data-lang="xml">NamevirtualHost *:80

<span class="nt">&lt;VirtualHost</span> <span class="err">*:80</span><span class="nt">&gt;</span>
	ServerName a.com
	DocumentRoot /var/www/site
<span class="nt">&lt;/VirtualHost&gt;</span>

<span class="nt">&lt;VirtualHost</span> <span class="err">*:80</span><span class="nt">&gt;</span>
	ServerName bbs.a.com
	DocumentRoot /var/www/bbs
<span class="nt">&lt;/VirtualHost&gt;</span></code></pre></div>

]]></content:encoded>
    </item>
    
    <item>
      <title>全排列算法（Java实现）</title>
      <link href="http://angelof7.github.io/permutation-array/"/>
      <pubDate>2015-04-29T00:00:00+08:00</pubDate>
      <author>andygc</author>
      <guid>http://angelof7.github.io/permutation-array</guid>
      <content:encoded><![CDATA[<p>设一组数p = {r1, r2, r3, … ,rn}, 全排列为perm(p)，pn = p - {rn}。</p>

<p>因此perm(p) = r1perm(p1), r2perm(p2), r3perm(p3), … , rnperm(pn)。当n = 1时perm(p} = r1。</p>

<p><strong>实现java代码如下：</strong></p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Permutate</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">swap</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">str</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span>
        <span class="o">{</span>
	        <span class="n">String</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">();</span>
	        <span class="n">temp</span> <span class="o">=</span> <span class="n">str</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
	        <span class="n">str</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">str</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
	        <span class="n">str</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">arrange</span> <span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">str</span><span class="o">,</span> <span class="kt">int</span> <span class="n">st</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">)</span>
        <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">st</span> <span class="o">==</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
                <span class="o">{</span>
                        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span> <span class="o">++)</span>
                        <span class="o">{</span>
                                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">str</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span> <span class="s">"  "</span><span class="o">);</span>
                        <span class="o">}</span>
                        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
                        <span class="n">total</span><span class="o">++;</span>
                <span class="o">}</span>
                <span class="k">else</span>
                <span class="o">{</span>
                        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">st</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span> <span class="o">++)</span>
                        <span class="o">{</span>
                                <span class="n">swap</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">st</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
                                <span class="n">arrange</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">st</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
                                <span class="n">swap</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">st</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
                        <span class="o">}</span>
                <span class="o">}</span>
		
        <span class="o">}</span>
	<span class="cm">/**
	 * @param args
	 */</span>
        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">String</span> <span class="n">str</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="s">"d"</span><span class="o">,</span> <span class="s">"e"</span><span class="o">};</span>
                <span class="n">arrange</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">total</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span></code></pre></div>

]]></content:encoded>
    </item>
    
  </channel>
</rss>
