---
layout: post
title: Linux中常用系统管理shell命令
categories: [shell]
tags: [Shell, Linux]
---

本篇博客记录常用的Linux系统管理shell

### ps
----------------
1. ps 的参数说明
    l       长格式输出； 
    u       按用户名和启动时间的顺序来显示进程； 
    j       用任务格式来显示进程； 
    f       用树形格式来显示进程； 
    a       显示所有用户的所有进程（包括其它用户）；  
    x       显示无控制终端的进程；  
    r       显示运行中的进程；  
    ww      避免详细参数被截断；  
*我们常用的选项是组合是aux -ef 输出的解释；*    
    USER    进程的属主；  
    PID     进程的ID；  
    PPID    父进程；  
    %CPU    进程占用的CPU百分比；  
    %MEM    占用内存的百分比；  
    NI      进程的NICE值，数值大，表示较少占用CPU时间；  
    VSZ     进程虚拟大小；  
    RSS     驻留中页的数量；  
    WCHAN   正在等待的进程资源   
    TTY     终端ID    
    STAT    进程状态   
    START   启动进程的时间；
    TIME    进程消耗CPU的时间；  
    COMMAND 命令的名称和参数；  
*实例*
    > ps -aux | more  
    > ps -aux > ps001.txt  
    > ps aux | grep httpd   
    > ps auxf |grep httpd  
pgrep 是通过程序的名字来查询进程的工具，一般是用来判断程序是否正在运行:   
常用参数:  
    -l      列出程序名和进程ID；  
    -o      进程起始的ID；  
    -n      进程终止的ID；  
    > pgrep -l httpd

### kill
---------------------------
#### kill  
kill的应用是和ps 或pgrep 命令结合在一起使用的；  
*用法*    
kill ［信号代码］   进程ID  
注：信号代码可以省略；我们常用的信号代码是 -9 ，表示强制终止；  

#### killall
killall 通过程序的名字，直接杀死所有进程，咱们简单说一下就行了。  
*用法*  
killall 正在运行的程序名    
killall 也和ps或pgrep 结合使用，比较方便；通过ps或pgrep 来查看哪些程序在运行；  
*举例*  
 >  [root@localhost beinan]# pgrep -l gaim  
 >  2979 gaim  
 >  [root@localhost beinan]# killall gaim  

#### pkill
pkill 和killall 应用方法差不多，也是直接杀死运行中的程序；如果您想杀掉单个进程，请用kill 来杀掉。  
*用法*  
pkill 正在运行的程序名  
*举例*  
>  [root@localhost beinan]# pgrep -l gaim

>  2979 gaim

>  [root@localhost beinan]# pkill gaim

#### xkill
xkill 是在桌面用的杀死图形界面的程序。比如当firefox 出现崩溃不能退出时，点鼠标就能杀死firefox 。当xkill运行时出来和个人脑骨的图标，哪个图形程序崩溃一点就OK了。如果您想终止xkill ，就按右键取消；
*用法*  
>  [root@localhost ~]# xkill

### top
-----------------------
TOP是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定.

total 进程总数  
running 正在运行的进程数  
sleeping 睡眠的进程数  
stopped 停止的进程数  
zombie 僵尸进程数  
Cpu(s):   
0.3% us 用户空间占用CPU百分比  
1.0% sy 内核空间占用CPU百分比  
0.0% ni 用户进程空间内改变过优先级的进程占用CPU百分比  
98.7% id 空闲CPU百分比  
0.0% wa 等待输入输出的CPU时间百分比  
0.0%hi：硬件CPU中断占用百分比  
0.0%si：软中断占用百分比  
0.0%st：虚拟机占用百分比  

Mem:  
191272k total    物理内存总量  
173656k used    使用的物理内存总量  
17616k free    空闲内存总量  
22052k buffers    用作内核缓存的内存量  
Swap:   
192772k total    交换区总量  
0k used    使用的交换区总量  
192772k free    空闲交换区总量  
123988k cached    缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小,相应的内存再次被换出时可不必再对交换区写入。  

序号  列名    含义  
a    PID     进程id  
b    PPID    父进程id  
c    RUSER   Real user name  
d    UID     进程所有者的用户id  
e    USER    进程所有者的用户名  
f    GROUP   进程所有者的组名  
g    TTY     启动进程的终端名。不是从终端启动的进程则显示为 ?  
h    PR      优先级  
i    NI      nice值。负值表示高优先级，正值表示低优先级  
j    P       最后使用的CPU，仅在多CPU环境下有意义  
k    %CPU    上次更新到现在的CPU时间占用百分比  
l    TIME    进程使用的CPU时间总计，单位秒  
m    TIME+   进程使用的CPU时间总计，单位1/100秒  
n    %MEM    进程使用的物理内存百分比  
o    VIRT    进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES  
p    SWAP    进程使用的虚拟内存中，被换出的大小，单位kb。  
q    RES     进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA  
r    CODE    可执行代码占用的物理内存大小，单位kb  
s    DATA    可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb  
t    SHR     共享内存大小，单位kb  
u    nFLT    页面错误次数  
v    nDRT    最后一次写入到现在，被修改过的页面数。  
w    S       进程状态(D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程)  
x    COMMAND 命令名/命令行  
y    WCHAN   若该进程在睡眠，则显示睡眠中的系统函数名  
z    Flags   任务标志，参考 sched.h  

#### top使用格式:
>  top [-] [d] [p] [q] [c] [C] [S] [s]  [n]

d 指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。 
p 通过指定监控进程ID来仅仅监控某个进程的状态。 
q 该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。 
S 指定累计模式 
s 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。 
i 使top不显示任何闲置或者僵死进程。 
c 显示整个命令行而不只是显示命令名

Ctrl+L 擦除并且重写屏幕。 

h或者? 显示帮助画面，给出一些简短的命令总结说明。 

k 终止一个进程。系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。 

i 忽略闲置和僵死进程。这是一个开关式命令。 

q 退出程序。 

r 重新安排一个进程的优先级别。系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。 

S 切换到累计模式。 

s 改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。 

f或者F 从当前显示中添加或者删除项目。 

o或者O 改变显示项目的顺序。 

l 切换显示平均负载和启动时间信息。 

m 切换显示内存信息。 

t 切换显示进程和CPU状态信息。 

c 切换显示命令名称和完整命令行。 

M 根据驻留内存大小进行排序。 

P 根据CPU使用百分比大小进行排序。 

T 根据时间/累计时间进行排序。 

W 将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。


### free
---------------
free命令由procps.*.rpm提供（在Redhat系列的OS上）。free命令的所有输出值都是从/proc/meminfo中读出的。

### 系统
-----------------------------------------
    # uname -a # 查看内核/操作系统/CPU信息  
    # head -n 1 /etc/issue # 查看操作系统版本  
    # cat /proc/cpuinfo # 查看CPU信息    
    # hostname # 查看计算机名  
    # lspci -tv # 列出所有PCI设备  
    # lsusb -tv # 列出所有USB设备  
    # lsmod # 列出加载的内核模块  
    # env # 查看环境变量  


### 资源
-------------------------------------------
    # free -m # 查看内存使用量和交换区使用量  
    # df -h # 查看各分区使用情况   
    # du -sh <目录名> # 查看指定目录的大小  
    # grep MemTotal /proc/meminfo # 查看内存总量  
    # grep MemFree /proc/meminfo # 查看空闲内存量  
    # uptime # 查看系统运行时间、用户数、负载  
    # cat /proc/loadavg # 查看系统负载  


### 磁盘和分区
------------------------------------------
    # mount | column -t # 查看挂接的分区状态  
    # fdisk -l # 查看所有分区  
    # swapon -s # 查看所有交换分区  
    # hdparm -i /dev/hda # 查看磁盘参数（仅适用于IDE设备）  
    # dmesg | grep IDE # 查看启动时IDE设备检测状况  


### 网络
-------------------------------------------
    # ifconfig # 查看所有网络接口的属性  
    # iptables -L # 查看防火墙设置  
    # route -n # 查看路由表  
    # netstat -lntp # 查看所有监听端口  
    # netstat -antp # 查看所有已经建立的连接  
    # netstat -s # 查看网络统计信息  


### 进程
------------------------------------------
    # ps -ef # 查看所有进程  
    # top # 实时显示进程状态  


### 用户
-------------------------------
    # w # 查看活动用户  
    # id <用户名> # 查看指定用户信息  
    # last # 查看用户登录日志  
    # cut -d: -f1 /etc/passwd # 查看系统所有用户  
    # cut -d: -f1 /etc/group # 查看系统所有组  
    # crontab -l # 查看当前用户的计划任务  


### 服务
----------------------------------------
    # chkconfig --list # 列出所有系统服务  
    # chkconfig --list | grep on # 列出所有启动的系统服务  

### 程序
-----------------------------------------
    # rpm -qa # 查看所有安装的软件包  

